---
title: IaC に取り組んでみたい...のでCopilotに相談してみた
description: この文書は、個人が管理するオンプレミスサーバおよび受託している顧客環境（ネットワーク分離）に対し、IaC（主にAnsible）を GitHub（Copilot / Actions）で運用する際の推奨方法をまとめたものです
date: 2025-12-13T03:35:49.074Z
draft: false
tags:
  - Ansible
  - IaC
  - Python
  - FreeBSD
categories:
  - Technology
---
# IaC に取り組んでみたい　のでCopilotに相談してみた

最近、なんでも相談しています。

## オンプレ（FreeBSD中心）IaC を GitHub（Copilot / Actions）で安全に運用する設計案（公開版）

この文書は、個人が管理するオンプレミスサーバおよび受託している顧客環境（ネットワーク分離）に対し、IaC（主にAnsible）を GitHub（Copilot / Actions）で運用する際の推奨方法をまとめたものです。  
ポイントは **「再利用可能なコード」と「秘匿すべき環境データ」を分離すること**、および **FreeBSD で発生しやすい Python/Ansible のバージョン差異コストを、実行環境の固定化で抑えること**です。

---

### 1. 前提と課題

#### 前提
- GitHub へのアクセスは原則として運用者（自分）に限定する（エンドユーザはGitHub運用知識を要求しない）
- 管理対象OSは **FreeBSDが中心**。一部に AWS 上の Ubuntu / Amazon Linux が存在する
- 顧客ごとにネットワークは分離されている
- CI/CD は **self-hosted runner 前提**（必要に応じて GitHub-hosted runner も併用可）

#### 課題（特に重要）
- **ターゲット側（FreeBSDなど）の Python バージョン差異・導入状態差異が運用コストを増大させる**
- runner側も Python 3.11 → 3.12 → 3.13… の移行に追従コストが発生
- AnsibleはRHEL系での前提が参照されがちで、FreeBSDでは当てはまらないことがある

---

### 2. 基本戦略（結論）

#### 2.1 リポジトリ分割：顧客境界を最優先にする
顧客ごとにネットワークが分離されているため、運用・監査・事故防止の観点から **顧客ごとに private repo を分ける**。

- 共通基盤（private推奨）: `iac-common`
  - 再利用可能な Ansible role/collection
  - lint/test（ansible-lint, yamllint）
  - Molecule（可能なら）や共通workflow
  - サンプル（ダミー）inventory/vars
- 顧客ごとの private repo: `iac-customer-xxxx`
  - 実際の inventory（ホスト名/IP等）
  - 顧客固有 vars
  - 適用 workflow（手動承認・実行）
  - 必要なら運用Runbook（顧客情報の扱いに注意）

この構成により「公開できる部分（共通ロジック）」と「秘匿すべき部分（実データ）」が自然に分離できる。

#### 2.2 実行環境固定化：Ansible実行側のPythonをコンテナで封じ込める
Ansible実行（runner）側のPython/Ansibleを **コンテナ（Execution Environment）に固定**して、アップグレード追随やpip破損を避ける。

- runnerホストに入れるものは極小化（例：Docker / Podman、GitHub runner、SSH到達性）
- Ansibleコマンドは常にコンテナ内で実行
- `requirements.yml` と collection/role のインストールもコンテナ内で行う

#### 2.3 ターゲット側（FreeBSD）のPython差異は「bootstrap」で吸収
FreeBSD中心では、ターゲット側のPython事情がサーバ世代・ポリシーで揺れやすい。  
ここは「Pythonを排除する」のではなく、**bootstrapを標準化して“期待状態”へ寄せる**。

- まず `raw` で最小限の前提（python3の導入、必要パッケージ、/usr/local/bin/python3 の確保など）を整備
- その後に通常のAnsibleモジュール運用へ移行

> FreeBSDでは OS標準と ports/pkg の組合せで差が出やすいため、bootstrapは（OSバージョン差分を吸収する）専用ロールまたは最初のplayとして切り出すのが有効。

---

### 3. Secrets/秘匿情報の扱い

#### 原則
- リポジトリに秘密の値を平文で入れない
- 入れるなら暗号化（Ansible Vault等）し、復号鍵は GitHub Secrets に置く

#### 推奨（段階的）
**PoC〜初期導入**: Ansible Vault + GitHub Environments Secrets  
**拡張**: SOPS + 外部Secrets管理（Vault/KMS） + OIDC（可能なら）

---

### 4. GitHub Actions 設計（self-hosted runner中心）

#### 4.1 ジョブの分離（推奨）
- PR（自動）: lint/testのみ（接続不要）
- main（手動）: apply（オンプレ接続あり、承認ゲートあり）

#### 4.2 runnerの分離（顧客境界）
- 顧客ごとに runner（VM/ホスト）を分け、該当顧客repoにのみ紐付ける
- ラベル例: `self-hosted`, `cust-foo`, `prod`

---

### 5. Copilotの位置づけ（漏洩リスク低減）
- Copilotの利用は共通コード（`iac-common`）の改善に寄せると安全
- 顧客固有repoでは、ホスト名/IP/顧客名等を含むテキストをプロンプトに貼り付けない
- 相談は抽象化した再現ケース（サンプルvars/ダミーinventory）で行う

---

### 6. 概念実証（PoC）— まず最小テストで成立性を確認する

PoCの目的は「本番適用」ではなく、次を最短で確認すること：
1. runner（コンテナ固定）で ansible が安定して動く
2. FreeBSDターゲットで bootstrap → 通常タスクへ移行できる
3. Secrets（Vault）と Actions の受け渡しが事故なく回る
4. 顧客ネットワーク分離（顧客ごとrunner分離）が運用可能

#### PoCのスコープ（最小）
- ターゲット: FreeBSD 1台（テスト用VM可） + Ubuntu/Amazon Linux 1台（任意）
- Playbook:
  - (1) bootstrap: python3導入確認 or 導入
  - (2) 共通タスク: 1ファイル配布、1サービス設定、1ユーザ作成 等（安全なもの）
- CI:
  - PRで lint（ansible-lint/yamllint）
  - 手動実行で apply（self-hosted runnerからSSH）

---

### 7. 次ステップ（PoC後）
- bootstrapのOS差分を整理（FreeBSD世代差、pkg/ports方針差）
- Molecule/テスト環境を増やす（FreeBSDはCIで再現しづらいのでVM/自前環境を使う）
- 監査/ログ（誰がいつapplyしたか）をworkflowログ＋タグで残す
- 外部Secrets管理へ移行（必要な場合）

---

## 感想

ここまで、一区切りしました。基本的にCopilot（＝AI）はせっかちです。
一年前だとここまでのまとまりを期待していなかった・・・というか、私が不明だった感じはあります。無論、全てを任せるわけにもいかず考えることや、緊急対応しなければならないことが入ってくると先延ばしになってしまいますが、私の時間を奪われないためには講じておこなければならないことです。